# GitHub Actions 工作流名称，会在Actions页面显示
name: CI/CD Pipeline

# 定义工作流的触发条件
on:
  # 当代码推送到指定分支时触发
  push:
    branches: [ main, develop ]  # 仅在main和develop分支推送时触发
  # 当创建Pull Request时触发
  pull_request:
    branches: [ main ]  # 仅针对main分支的PR触发

permissions:
  security-events: write
  actions: read
  contents: read

# 全局环境变量，所有作业都可以访问
env:
  CARGO_TERM_COLOR: always  # 让Rust编译器输出彩色信息，便于调试
  NODE_VERSION: '24.7'        # 统一指定Node.js版本，确保环境一致性
  RUST_VERSION: '1.87'      # 统一指定Rust版本，确保编译一致性

# 定义作业列表，每个作业在独立的虚拟机中运行
jobs:
  # 前端构建和测试作业
  frontend:
    name: Frontend Build & Test  # 作业的显示名称
    runs-on: ubuntu-latest       # 指定运行环境为最新版Ubuntu
    defaults:                    # 设置默认配置
      run:                       # 所有run步骤的默认设置
        working-directory: ./frontend  # 默认工作目录设为frontend文件夹
    
    # 作业步骤列表，按顺序执行
    steps:
    # 第一步：检出代码到运行环境
    - name: Checkout code
      uses: actions/checkout@v4  # 使用官方checkout action v4版本
    
    # 第二步：设置Node.js环境
    - name: Setup Node.js
      uses: actions/setup-node@v4  # 使用官方Node.js设置action
      with:                        # action的输入参数
        node-version: ${{ env.NODE_VERSION }}  # 使用环境变量中定义的Node版本
        cache: 'npm'               # 启用npm缓存，加速依赖安装
        cache-dependency-path: frontend/package-lock.json  # 指定缓存依赖文件路径
    
    # 第三步：安装项目依赖
    - name: Install dependencies
      run: npm ci  # 使用npm ci进行清洁安装，比npm install更适合CI环境
    
    # 第四步：运行ESLint代码检查
    - name: Run ESLint
      run: npm run lint  # 执行package.json中定义的lint脚本
    
    # 第五步：检查TypeScript类型和代码格式
    - name: Check TypeScript
      run: npm run format:check  # 执行格式检查脚本
    
    # 第六步：构建前端应用
    - name: Build frontend
      run: npm run build  # 执行构建脚本，生成生产版本
    
    # 第七步：上传构建产物供其他作业使用
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4  # 使用官方上传artifact action
      with:                             # action参数
        name: frontend-dist             # artifact名称
        path: frontend/dist/            # 要上传的文件路径
        retention-days: 7               # 保留天数，7天后自动删除

  # 后端构建和测试作业
  backend:
    name: Backend Build & Test  # 作业显示名称
    runs-on: ubuntu-latest      # 运行环境
    defaults:                   # 默认设置
      run:
        working-directory: ./backend  # 默认工作目录为backend
    
    # 服务容器配置，为作业提供数据库等服务
    services:
      postgres:                 # PostgreSQL服务容器
        image: postgres:15      # 使用PostgreSQL 15镜像
        env:                    # 容器环境变量
          POSTGRES_PASSWORD: postgres    # 数据库密码
          POSTGRES_DB: media_hub_test   # 测试数据库名
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5  # 健康检查配置
        ports:                  # 端口映射
          - 5432:5432          # 将容器5432端口映射到主机5432端口
    
    steps:
    # 检出代码
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 设置Rust开发环境
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable  # 使用社区维护的Rust工具链action
      with:
        toolchain: ${{ env.RUST_VERSION }}  # 指定Rust版本
        components: rustfmt, clippy         # 安装格式化和静态分析组件
    
    # 缓存Rust依赖，加速构建
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2  # 使用社区维护的Rust缓存action
      with:
        workspaces: backend           # 指定要缓存的工作空间
    
    # 检查Rust代码格式
    - name: Check Rust formatting
      run: cargo fmt --all -- --check  # 检查所有包的代码格式，不符合则失败
    
    # 运行Clippy静态分析
    - name: Run Clippy
      run: cargo clippy --all-targets --all-features  # 对所有目标和特性运行clippy，允许警告存在
    
    # 运行单元测试和集成测试
    - name: Run tests
      run: cargo test --verbose  # 详细模式运行所有测试
      env:                       # 测试环境变量
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/media_hub_test  # 测试数据库连接字符串
    
    # 构建发布版本
    - name: Build release
      run: cargo build --release --verbose  # 构建优化的发布版本
    
    # 上传后端二进制文件
    - name: Upload backend binary
      uses: actions/upload-artifact@v4
      with:
        name: backend-binary                        # artifact名称
        path: backend/target/release/media-server   # 二进制文件路径
        retention-days: 7                           # 保留7天

  # WASM模块构建作业
  wasm:
    name: WASM Build           # 作业名称
    runs-on: ubuntu-latest     # 运行环境
    defaults:
      run:
        working-directory: ./backend/media-wasm  # WASM项目目录
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 设置Rust环境，包含WASM目标
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: ${{ env.RUST_VERSION }}
        targets: wasm32-unknown-unknown  # 添加WASM编译目标
    
    # 安装wasm-pack工具
    - name: Install wasm-pack
      run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh  # 从官方脚本安装
    
    # 缓存WASM项目依赖
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: backend/media-wasm  # 指定WASM工作空间
    
    # 构建WASM包
    - name: Build WASM package
      run: wasm-pack build --target web --out-dir pkg  # 构建Web目标的WASM包
    
    # 上传WASM构建产物
    - name: Upload WASM artifacts
      uses: actions/upload-artifact@v4
      with:
        name: wasm-pkg                    # artifact名称
        path: backend/media-wasm/pkg/     # WASM包路径
        retention-days: 7

  # 安全扫描作业
  security:
    name: Security Scan       # 作业名称
    runs-on: ubuntu-latest    # 运行环境
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 使用Trivy进行安全漏洞扫描
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master  # 使用Aqua Security的Trivy action
      with:
        scan-type: 'fs'                # 扫描类型：文件系统
        scan-ref: '.'                  # 扫描当前目录
        format: 'sarif'                # 输出格式：SARIF（静态分析结果交换格式）
        output: 'trivy-results.sarif'  # 输出文件名
    
    # 上传安全扫描结果到GitHub Security
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3  # 使用GitHub官方CodeQL action上传SARIF
      if: always()                                # 无论前面步骤是否成功都执行
      with:
        sarif_file: 'trivy-results.sarif'        # SARIF文件路径

  # 集成测试作业
  integration:
    name: Integration Tests   # 作业名称
    runs-on: ubuntu-latest    # 运行环境
    needs: [frontend, backend]  # 依赖前端和后端作业完成
    
    # 集成测试需要的服务
    services:
      postgres:               # PostgreSQL服务
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: media_hub_test
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5  # 健康检查配置
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 下载后端二进制文件
    - name: Download backend binary
      uses: actions/download-artifact@v4  # 使用官方下载artifact action
      with:
        name: backend-binary               # 要下载的artifact名称
        path: ./backend/target/release/    # 下载到的路径
    
    # 下载前端构建产物
    - name: Download frontend build
      uses: actions/download-artifact@v4
      with:
        name: frontend-dist     # 前端构建产物名称
        path: ./frontend/dist/  # 下载路径
    
    # 给二进制文件添加执行权限
    - name: Make binary executable
      run: chmod +x ./backend/target/release/media-server  # 添加执行权限
    
    # 设置测试环境变量
    - name: Setup test environment
      run: |
        echo "DATABASE_URL=postgres://postgres:postgres@localhost:5432/media_hub_test" > .env
        echo "JWT_SECRET=test-secret-key-for-ci" >> .env
        echo "RUST_LOG=info" >> .env
    
    # 运行集成测试
    - name: Run integration tests
      run: |
        # 后台启动后端服务
        ./backend/target/release/media-server &
        SERVER_PID=$!  # 保存进程ID
        
        # 等待服务启动
        sleep 10
        
        # 测试健康检查端点
        curl -f http://localhost:8000/api/health || exit 1
        
        # 清理：杀死后端进程
        kill $SERVER_PID
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/media_hub_test

  # Docker镜像构建作业
  docker:
    name: Build Docker Images     # 作业名称
    runs-on: ubuntu-latest        # 运行环境
    needs: [frontend, backend, wasm]  # 依赖前端、后端、WASM作业完成
    if: github.ref == 'refs/heads/main'  # 仅在main分支执行
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 设置Docker Buildx（支持多平台构建）
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3  # 使用官方Docker Buildx设置action
    
    # 登录Docker Hub
    - name: Login to Docker Hub
      uses: docker/login-action@v3  # 使用官方Docker登录action
      with:
        username: ${{ secrets.DOCKER_USERNAME }}  # 从GitHub Secrets获取用户名
        password: ${{ secrets.DOCKER_PASSWORD }}  # 从GitHub Secrets获取密码
    
    # 下载所有构建产物
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts  # 下载所有artifacts到artifacts目录
    
    # 构建并推送后端Docker镜像
    - name: Build and push backend image
      uses: docker/build-push-action@v5  # 使用官方Docker构建推送action
      with:
        context: .                        # 构建上下文为当前目录
        file: ./backend/Dockerfile        # Dockerfile路径
        push: true                        # 构建后推送到registry
        tags: |                           # 镜像标签列表
          ${{ secrets.DOCKER_USERNAME }}/media-hub-backend:latest
          ${{ secrets.DOCKER_USERNAME }}/media-hub-backend:${{ github.sha }}
        cache-from: type=gha              # 使用GitHub Actions缓存
        cache-to: type=gha,mode=max       # 缓存所有层
    
    # 构建并推送前端Docker镜像
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./frontend/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/media-hub-frontend:latest
          ${{ secrets.DOCKER_USERNAME }}/media-hub-frontend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # 生产环境部署作业
  deploy:
    name: Deploy to Production       # 作业名称
    runs-on: ubuntu-latest           # 运行环境
    needs: [integration, docker]     # 依赖集成测试和Docker构建完成
    if: github.ref == 'refs/heads/main'  # 仅在main分支执行
    environment: production          # 指定部署环境，可以设置保护规则
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # 复制docker-compose.yml到服务器
    - name: Copy docker-compose.yml to server
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.DEPLOY_HOST }}
        username: ${{ secrets.DEPLOY_USER }}
        key: ${{ secrets.DEPLOY_KEY }}
        source: "docker-compose.yml"
        target: "/opt/media-hub/"
    
    # 通过SSH部署到生产服务器
    - name: Deploy to server
      uses: appleboy/ssh-action@v1.0.3  # 使用社区维护的SSH action
      with:
        host: ${{ secrets.DEPLOY_HOST }}     # 服务器地址（从Secrets获取）
        username: ${{ secrets.DEPLOY_USER }} # SSH用户名（从Secrets获取）
        key: ${{ secrets.DEPLOY_KEY }}       # SSH私钥（从Secrets获取）
        script: |                            # 在服务器上执行的脚本
          cd /opt/media-hub                  # 进入部署目录
          docker compose pull               # 拉取最新镜像
          docker compose up -d --remove-orphans  # 启动服务，移除孤立容器
          docker system prune -f            # 清理未使用的Docker资源